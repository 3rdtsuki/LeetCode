```java
class Solution {
    boolean[] visited=new boolean[7];//避免重复访问
    void dfs(int[] nums,List<List<Integer>>res,List<Integer>current){
        int n=nums.length;
        if(current.size()==n){
            res.add(new ArrayList<>(current));//java中一定要新建一个数组，否则跟随原来的变化
            return;
        }
        for(int i=0;i<n;++i){
            if(visited[i]==false){
                current.add(nums[i]);
                visited[i]=true;
                dfs(nums,res,current);
                current.remove(current.size()-1);
                visited[i]=false;
            }
        }
    }
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>>res=new ArrayList<>();
        dfs(nums,res,new ArrayList<Integer>());
        return res;
    }
}
```
回溯的关键就是知道dfs函数每趟结束后回到哪继续执行，例如dfs([1,2])->add(3)->dfs([1,2,3])->remove(3)->remove(2)->add(3)->dfs([1,3])

![全排列的回溯原理.png](https://pic.leetcode-cn.com/1648096830-EfPcLs-%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E5%9B%9E%E6%BA%AF%E5%8E%9F%E7%90%86.png)
